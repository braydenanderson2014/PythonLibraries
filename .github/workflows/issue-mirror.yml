# .github/workflows/issue-mirror.yml
name: Issue Mirror

on:
  workflow_dispatch:
    inputs:
      issue_number:
        description: "Issue number to sync (from THIS repo)"
        required: true
        type: string
      target_owner:
        description: "Override target owner/org (optional; defaults to repo var)"
        required: false
        type: string
      target_repo:
        description: "Override target repo name (optional; defaults to repo var)"
        required: false
        type: string
  issues:
    types: [opened, edited, closed, reopened, labeled, unlabeled]
  issue_comment:
    types: [created, edited, deleted]

permissions:
  contents: read
  issues: write

env:
  MIRROR_TARGET_OWNER: ${{ vars.MIRROR_TARGET_OWNER }}
  MIRROR_TARGET_REPO:  ${{ vars.MIRROR_TARGET_REPO }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    # Allow manual runs even if repo vars aren't set (inputs can provide them)
    if: ${{ github.event_name == 'workflow_dispatch' || (vars.MIRROR_TARGET_OWNER != '' && vars.MIRROR_TARGET_REPO != '') }}
    steps:
      - name: Mirror issue and comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const crypto = require('crypto');

            // ---- Helpers / context ----
            const ctx = context;
            const inputs = ctx.payload.inputs || {};
            const isManual = ctx.eventName === 'workflow_dispatch';
            const isIssueEvent = !!ctx.payload.issue;
            const isCommentEvent = !!ctx.payload.comment;

            const SRC_OWNER = ctx.repo.owner;
            const SRC_REPO  = ctx.repo.repo;
            const SRC_ISSUE_NUMBER = isManual ? parseInt((inputs.issue_number || ''), 10) : ctx.payload.issue.number;

            const TARGET_OWNER = inputs.target_owner || process.env.MIRROR_TARGET_OWNER;
            const TARGET_REPO  = inputs.target_repo  || process.env.MIRROR_TARGET_REPO;

            if (!TARGET_OWNER || !TARGET_REPO) {
              core.setFailed('Target owner/repo not configured. Set repo variables MIRROR_TARGET_OWNER/MIRROR_TARGET_REPO or pass target_owner/target_repo via workflow_dispatch inputs.');
              return;
            }
            if (isManual && !SRC_ISSUE_NUMBER) {
              core.setFailed('Manual run requires an issue_number input.');
              return;
            }

            const MIRROR_TAG_RE = /<!--\s*MIRROR:\s*([^#\s\/]+)\/(\S+?)#(\d+)\s*\|\s*hash:\s*([a-f0-9]{40})\s*-->/i;
            const COMMENT_ORIG_TAG_RE = /<!--\s*ORIG_COMMENT_ID:(\d+)\s*-->/i;

            function stripMirrorTag(body) {
              if (!body) return '';
              return body.replace(MIRROR_TAG_RE, '').trim();
            }

            function computeIssueHash({ title, body, labels, state }) {
              const norm = {
                title: title || '',
                body: stripMirrorTag(body || ''),
                labels: (labels || []).map(l => (typeof l === 'string' ? l : l.name)).sort(),
                state: state || 'open'
              };
              const str = JSON.stringify(norm);
              return crypto.createHash('sha1').update(str).digest('hex');
            }

            function embedMirrorTag(body, targetOwner, targetRepo, targetNumber, hash) {
              const tag = `<!-- MIRROR: ${targetOwner}/${targetRepo}#${targetNumber} | hash: ${hash} -->`;
              const clean = stripMirrorTag(body || '');
              return `${clean}\n\n${tag}`.trim();
            }

            async function ensureLabelsExist(target, labels) {
              const byName = {};
              for (const l of labels) {
                const name = typeof l === 'string' ? l : l.name;
                const color = typeof l === 'string' ? 'ededed' : (l.color || 'ededed');
                const description = typeof l === 'string' ? '' : (l.description || '');
                if (!name) continue;
                if (byName[name]) continue;
                byName[name] = { color, description };
              }
              for (const [name, meta] of Object.entries(byName)) {
                try {
                  await github.rest.issues.getLabel({ ...target, name });
                } catch (e) {
                  if (e.status === 404) {
                    await github.rest.issues.createLabel({ ...target, name, color: meta.color, description: meta.description });
                  } else {
                    throw e;
                  }
                }
              }
            }

            async function findOrCreateTargetIssue(source, targetBase) {
              const srcIssue = (await github.rest.issues.get({ ...source })).data;

              // Try to find back-reference in source to existing counterpart
              const m = MIRROR_TAG_RE.exec(srcIssue.body || '');
              if (m) {
                const [, towner, trepo, tnum] = m;
                const num = parseInt(tnum, 10);
                try {
                  const tgtIssue = (await github.rest.issues.get({ owner: towner, repo: trepo, issue_number: num })).data;
                  return { srcIssue, tgtIssue, existing: true };
                } catch {
                  // counterpart missing; create anew
                }
              }

              const labels = srcIssue.labels.map(l => ({ name: l.name, color: l.color, description: l.description }));
              await ensureLabelsExist(targetBase, labels);

              const srcHash = computeIssueHash({
                title: srcIssue.title,
                body: srcIssue.body,
                labels: labels.map(l => l.name),
                state: srcIssue.state
              });

              const created = (await github.rest.issues.create({
                ...targetBase,
                title: srcIssue.title,
                body: embedMirrorTag(srcIssue.body || '', source.owner, source.repo, source.issue_number, srcHash),
                labels: labels.map(l => l.name),
                state: srcIssue.state
              })).data;

              // Add back-reference onto source
              const tgtHash = computeIssueHash({
                title: created.title,
                body: created.body,
                labels: created.labels.map(l => l.name),
                state: created.state
              });

              await github.rest.issues.update({
                ...source,
                body: embedMirrorTag(srcIssue.body || '', targetBase.owner, targetBase.repo, created.number, tgtHash)
              });

              // Reload source (now with backref)
              const reloaded = (await github.rest.issues.get({ ...source })).data;
              return { srcIssue: reloaded, tgtIssue: created, existing: false };
            }

            async function syncIssueCore(source, target, srcIssue, tgtIssue) {
              const srcLabels = srcIssue.labels.map(l => ({ name: l.name, color: l.color, description: l.description }));
              const tgtLabels = tgtIssue.labels.map(l => ({ name: l.name, color: l.color, description: l.description }));

              await ensureLabelsExist({ owner: target.owner, repo: target.repo }, srcLabels);

              const desired = {
                title: srcIssue.title,
                body: embedMirrorTag(
                  srcIssue.body || '',
                  target.owner, target.repo, tgtIssue.number,
                  computeIssueHash({
                    title: srcIssue.title,
                    body: srcIssue.body,
                    labels: srcLabels.map(l=>l.name),
                    state: srcIssue.state
                  })
                ),
                labels: srcLabels.map(l => l.name),
                state: srcIssue.state
              };

              // Quick convergence checks
              const currentHashMatch = MIRROR_TAG_RE.exec(tgtIssue.body || '');
              const currentHash = currentHashMatch ? currentHashMatch[4] : null;
              const desiredHash = computeIssueHash({
                title: desired.title,
                body: desired.body,
                labels: desired.labels,
                state: desired.state
              });

              const needTitle = tgtIssue.title !== desired.title;
              const needBody  = stripMirrorTag(tgtIssue.body || '') !== stripMirrorTag(desired.body || '');
              const needState = tgtIssue.state !== desired.state;
              const haveLabels = tgtLabels.map(l=>l.name).sort().join(',');
              const wantLabels = desired.labels.slice().sort().join(',');
              const needLabels = haveLabels !== wantLabels;

              if (currentHash && currentHash === desiredHash && !needLabels) {
                core.info('Target already up to date (hash match).');
              } else {
                await github.rest.issues.update({ ...target, issue_number: tgtIssue.number, title: desired.title, body: desired.body, state: desired.state });
                if (needLabels) {
                  await github.rest.issues.setLabels({ ...target, issue_number: tgtIssue.number, labels: desired.labels });
                }
              }
            }

            async function syncComments(source, target, srcIssue, tgtIssue) {
              const srcComments = await github.paginate(github.rest.issues.listComments, { ...source, per_page: 100 });
              const tgtComments = await github.paginate(github.rest.issues.listComments, { ...target, issue_number: tgtIssue.number, per_page: 100 });

              const COMMENT_ORIG_TAG_RE = /<!--\s*ORIG_COMMENT_ID:(\d+)\s*-->/i;
              const tgtByOrigId = new Map();
              for (const c of tgtComments) {
                const m = COMMENT_ORIG_TAG_RE.exec(c.body || '');
                if (m) tgtByOrigId.set(m[1], c);
              }

              // Create/update
              for (const c of srcComments) {
                const origId = String(c.id);
                const srcBodyCore = (c.body || '').replace(COMMENT_ORIG_TAG_RE, '').trim();
                if (tgtByOrigId.has(origId)) {
                  const existing = tgtByOrigId.get(origId);
                  const tgtBodyCore = (existing.body || '').replace(COMMENT_ORIG_TAG_RE, '').trim();
                  if (srcBodyCore !== tgtBodyCore) {
                    await github.rest.issues.updateComment({ ...target, comment_id: existing.id, body: `${srcBodyCore}\n\n<!-- ORIG_COMMENT_ID:${origId} -->` });
                  }
                } else {
                  await github.rest.issues.createComment({ ...target, issue_number: tgtIssue.number, body: `${srcBodyCore}\n\n<!-- ORIG_COMMENT_ID:${origId} -->` });
                }
              }

              // Deletions
              const srcIds = new Set(srcComments.map(c => String(c.id)));
              for (const [origId, existing] of tgtByOrigId.entries()) {
                if (!srcIds.has(origId)) {
                  await github.rest.issues.deleteComment({ ...target, comment_id: existing.id });
                }
              }
            }

            async function mirrorFlow() {
              const source = { owner: SRC_OWNER, repo: SRC_REPO, issue_number: SRC_ISSUE_NUMBER };
              const targetBase = { owner: TARGET_OWNER, repo: TARGET_REPO };

              const { srcIssue, tgtIssue } = await findOrCreateTargetIssue(source, targetBase);

              if (isCommentEvent) {
                await syncComments(source, { ...targetBase, issue_number: tgtIssue.number }, srcIssue, tgtIssue);
                return;
              }

              await syncIssueCore(source, { ...targetBase, issue_number: tgtIssue.number }, srcIssue, tgtIssue);
              await syncComments(source, { ...targetBase, issue_number: tgtIssue.number }, srcIssue, tgtIssue);
            }

            await mirrorFlow();
