# .github/workflows/issue-mirror.yml
name: Issue Mirror

on:
  workflow_dispatch:
    inputs:
      # Option A: sync FROM THIS repo → target repo
      issue_number:
        description: "Issue number in THIS repo to mirror to the target"
        required: false
        type: string
      target_owner:
        description: "Override target owner/org (optional; defaults to repo var)"
        required: false
        type: string
      target_repo:
        description: "Override target repo (optional; defaults to repo var)"
        required: false
        type: string
      # Option B: sync FROM ANOTHER repo → THIS repo
      source_owner:
        description: "Source owner/org (optional; defaults to MIRROR_TARGET_OWNER or this owner)"
        required: false
        type: string
      source_repo:
        description: "Source repo (optional; defaults to MIRROR_TARGET_REPO or this repo)"
        required: false
        type: string
      source_issue:
        description: "Issue number in SOURCE repo to mirror into THIS repo"
        required: false
        type: string
  issues:
    types: [opened, edited, closed, reopened, labeled, unlabeled]
  issue_comment:
    types: [created, edited, deleted]

permissions:
  contents: read
  issues: write

env:
  MIRROR_TARGET_OWNER: ${{ vars.MIRROR_TARGET_OWNER }}
  MIRROR_TARGET_REPO:  ${{ vars.MIRROR_TARGET_REPO }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    # Allow manual runs even if repo vars aren't set (inputs can provide them)
    if: ${{ github.event_name == 'workflow_dispatch' || (vars.MIRROR_TARGET_OWNER != '' && vars.MIRROR_TARGET_REPO != '') }}
    steps:
      - name: Mirror issue and comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const crypto = require('crypto');
            const ctx = context;
            const inputs = ctx.payload.inputs || {};
            const isManual = ctx.eventName === 'workflow_dispatch';
            const isIssueEvent = !!ctx.payload.issue;
            const isCommentEvent = !!ctx.payload.comment;

            // Defaults from repo vars
            const DEFAULT_TARGET_OWNER = process.env.MIRROR_TARGET_OWNER;
            const DEFAULT_TARGET_REPO  = process.env.MIRROR_TARGET_REPO;

            // Resolve source/target depending on trigger
            let source = null;      // { owner, repo, issue_number }
            let targetBase = null;  // { owner, repo }

            if (isManual) {
              const hasSourcePull = !!inputs.source_issue;
              const hasThisPush   = !!inputs.issue_number;

              if (hasSourcePull && hasThisPush) {
                core.setFailed('Provide either source_issue (pull into this repo) OR issue_number (push to target), not both.');
                return;
              }

              if (hasSourcePull) {
                // Pull: FROM external -> THIS repo
                const sOwner = inputs.source_owner || DEFAULT_TARGET_OWNER || ctx.repo.owner;
                const sRepo  = inputs.source_repo  || DEFAULT_TARGET_REPO  || ctx.repo.repo;
                const sNum   = parseInt((inputs.source_issue || ''), 10);
                if (!sNum) { core.setFailed('Manual pull requires a numeric source_issue.'); return; }
                source = { owner: sOwner, repo: sRepo, issue_number: sNum };
                targetBase = { owner: ctx.repo.owner, repo: ctx.repo.repo };
              } else if (hasThisPush) {
                // Push: FROM this repo -> target
                const sNum = parseInt((inputs.issue_number || ''), 10);
                if (!sNum) { core.setFailed('Manual push requires a numeric issue_number.'); return; }
                source = { owner: ctx.repo.owner, repo: ctx.repo.repo, issue_number: sNum };
                const tOwner = inputs.target_owner || DEFAULT_TARGET_OWNER;
                const tRepo  = inputs.target_repo  || DEFAULT_TARGET_REPO;
                if (!tOwner || !tRepo) {
                  core.setFailed('Target repo not configured. Set repo variables MIRROR_TARGET_OWNER/MIRROR_TARGET_REPO or pass target_owner/target_repo.');
                  return;
                }
                targetBase = { owner: tOwner, repo: tRepo };
              } else {
                core.setFailed('Manual run: provide either issue_number (push) OR source_issue (pull).');
                return;
              }
            } else {
              // Event-driven: this repo -> configured target
              const tOwner = DEFAULT_TARGET_OWNER;
              const tRepo  = DEFAULT_TARGET_REPO;
              if (!tOwner || !tRepo) { core.setFailed('Target repo not configured via repo variables.'); return; }
              source = { owner: ctx.repo.owner, repo: ctx.repo.repo, issue_number: ctx.payload.issue.number };
              targetBase = { owner: tOwner, repo: tRepo };
            }

            // --- Helpers for mirroring ---
            const MIRROR_TAG_RE = /<!--\s*MIRROR:\s*([^#\s\/]+)\/(\S+?)#(\d+)\s*\|\s*hash:\s*([a-f0-9]{40})\s*-->/i;
            const COMMENT_ORIG_TAG_RE = /<!--\s*ORIG_COMMENT_ID:(\d+)\s*-->/i;

            function stripMirrorTag(body) {
              if (!body) return '';
              return body.replace(MIRROR_TAG_RE, '').trim();
            }

            function computeIssueHash({ title, body, labels, state }) {
              const norm = {
                title: title || '',
                body: stripMirrorTag(body || ''),
                labels: (labels || []).map(l => (typeof l === 'string' ? l : l.name)).sort(),
                state: state || 'open'
              };
              const str = JSON.stringify(norm);
              return crypto.createHash('sha1').update(str).digest('hex');
            }

            function embedMirrorTag(body, targetOwner, targetRepo, targetNumber, hash) {
              const tag = `<!-- MIRROR: ${targetOwner}/${targetRepo}#${targetNumber} | hash: ${hash} -->`;
              const clean = stripMirrorTag(body || '');
              return `${clean}\n\n${tag}`.trim();
            }

            async function ensureLabelsExist(targetRepoRef, labels) {
              const byName = {};
              for (const l of labels) {
                const name = typeof l === 'string' ? l : l.name;
                const color = typeof l === 'string' ? 'ededed' : (l.color || 'ededed');
                const description = typeof l === 'string' ? '' : (l.description || '');
                if (!name) continue;
                if (byName[name]) continue;
                byName[name] = { color, description };
              }
              for (const [name, meta] of Object.entries(byName)) {
                try {
                  await github.rest.issues.getLabel({ ...targetRepoRef, name });
                } catch (e) {
                  if (e.status === 404) {
                    await github.rest.issues.createLabel({ ...targetRepoRef, name, color: meta.color, description: meta.description });
                  } else {
                    throw e;
                  }
                }
              }
            }

            async function findOrCreateTargetIssue(source, targetBase) {
              const srcIssue = (await github.rest.issues.get({ ...source })).data;

              // Check if the source already points to a counterpart
              const m = MIRROR_TAG_RE.exec(srcIssue.body || '');
              if (m) {
                const [, towner, trepo, tnum] = m;
                const num = parseInt(tnum, 10);
                try {
                  const tgtIssue = (await github.rest.issues.get({ owner: towner, repo: trepo, issue_number: num })).data;
                  return { srcIssue, tgtIssue, existing: true };
                } catch {
                  // counterpart missing; will recreate
                }
              }

              // Create new counterpart
              const labels = srcIssue.labels.map(l => ({ name: l.name, color: l.color, description: l.description }));
              await ensureLabelsExist(targetBase, labels);

              const srcHash = computeIssueHash({
                title: srcIssue.title,
                body: srcIssue.body,
                labels: labels.map(l => l.name),
                state: srcIssue.state
              });

              const created = (await github.rest.issues.create({
                ...targetBase,
                title: srcIssue.title,
                body: embedMirrorTag(srcIssue.body || '', source.owner, source.repo, source.issue_number, srcHash),
                labels: labels.map(l => l.name),
                state: srcIssue.state
              })).data;

              // Add back-reference on source
              const tgtHash = computeIssueHash({
                title: created.title,
                body: created.body,
                labels: created.labels.map(l => l.name),
                state: created.state
              });

              await github.rest.issues.update({
                ...source,
                body: embedMirrorTag(srcIssue.body || '', targetBase.owner, targetBase.repo, created.number, tgtHash)
              });

              const reloaded = (await github.rest.issues.get({ ...source })).data;
              return { srcIssue: reloaded, tgtIssue: created, existing: false };
            }

            async function syncIssueCore(source, target, srcIssue, tgtIssue) {
              const srcLabels = srcIssue.labels.map(l => ({ name: l.name, color: l.color, description: l.description }));
              const tgtLabels = tgtIssue.labels.map(l => ({ name: l.name, color: l.color, description: l.description }));

              await ensureLabelsExist({ owner: target.owner, repo: target.repo }, srcLabels);

              const desired = {
                title: srcIssue.title,
                body: embedMirrorTag(
                  srcIssue.body || '',
                  target.owner, target.repo, tgtIssue.number,
                  computeIssueHash({
                    title: srcIssue.title,
                    body: srcIssue.body,
                    labels: srcLabels.map(l=>l.name),
                    state: srcIssue.state
                  })
                ),
                labels: srcLabels.map(l => l.name),
                state: srcIssue.state
              };

              const MIRROR_TAG_RE_LOCAL = /<!--\s*MIRROR:\s*([^#\s\/]+)\/(\S+?)#(\d+)\s*\|\s*hash:\s*([a-f0-9]{40})\s*-->/i;
              const currentHashMatch = MIRROR_TAG_RE_LOCAL.exec(tgtIssue.body || '');
              const currentHash = currentHashMatch ? currentHashMatch[4] : null;
              const desiredHash = computeIssueHash({
                title: desired.title,
                body: desired.body,
                labels: desired.labels,
                state: desired.state
              });

              const needBody  = stripMirrorTag(tgtIssue.body || '') !== stripMirrorTag(desired.body || '');
              const needTitle = tgtIssue.title !== desired.title;
              const needState = tgtIssue.state !== desired.state;
              const haveLabels = tgtLabels.map(l=>l.name).sort().join(',');
              const wantLabels = desired.labels.slice().sort().join(',');
              const needLabels = haveLabels !== wantLabels;

              if (currentHash && currentHash === desiredHash && !needLabels && !needTitle && !needState) {
                core.info('Target already up to date (hash match).');
              } else {
                await github.rest.issues.update({
                  ...target,
                  issue_number: tgtIssue.number,
                  title: desired.title,
                  body: desired.body,
                  state: desired.state
                });
                if (needLabels) {
                  await github.rest.issues.setLabels({ ...target, issue_number: tgtIssue.number, labels: desired.labels });
                }
              }
            }

            async function syncComments(source, target, srcIssue, tgtIssue) {
              const srcComments = await github.paginate(github.rest.issues.listComments, { ...source, per_page: 100 });
              const tgtComments = await github.paginate(github.rest.issues.listComments, { ...target, issue_number: tgtIssue.number, per_page: 100 });

              const tgtByOrigId = new Map();
              for (const c of tgtComments) {
                const m = COMMENT_ORIG_TAG_RE.exec(c.body || '');
                if (m) tgtByOrigId.set(m[1], c);
              }

              // Create/update
              for (const c of srcComments) {
                const origId = String(c.id);
                const srcBodyCore = (c.body || '').replace(COMMENT_ORIG_TAG_RE, '').trim();
                if (tgtByOrigId.has(origId)) {
                  const existing = tgtByOrigId.get(origId);
                  const tgtBodyCore = (existing.body || '').replace(COMMENT_ORIG_TAG_RE, '').trim();
                  if (srcBodyCore !== tgtBodyCore) {
                    await github.rest.issues.updateComment({ ...target, comment_id: existing.id, body: `${srcBodyCore}\n\n<!-- ORIG_COMMENT_ID:${origId} -->` });
                  }
                } else {
                  await github.rest.issues.createComment({ ...target, issue_number: tgtIssue.number, body: `${srcBodyCore}\n\n<!-- ORIG_COMMENT_ID:${origId} -->` });
                }
              }

              // Deletions
              const srcIds = new Set(srcComments.map(c => String(c.id)));
              for (const [origId, existing] of tgtByOrigId.entries()) {
                if (!srcIds.has(origId)) {
                  await github.rest.issues.deleteComment({ ...target, comment_id: existing.id });
                }
              }
            }

            async function mirrorFlow() {
              const { srcIssue, tgtIssue } = await findOrCreateTargetIssue(source, targetBase);

              if (isCommentEvent) {
                await syncComments(source, { ...targetBase, issue_number: tgtIssue.number }, srcIssue, tgtIssue);
                return;
              }

              await syncIssueCore(source, { ...targetBase, issue_number: tgtIssue.number }, srcIssue, tgtIssue);
              await syncComments(source, { ...targetBase, issue_number: tgtIssue.number }, srcIssue, tgtIssue);
            }

            await mirrorFlow();
