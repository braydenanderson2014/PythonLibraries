# .github/workflows/issue-mirror.yml
# Bi-directional issue mirroring between two repositories (public/private)
# - Mirrors title, body, state (open/closed), labels, and comments
# - Creates missing labels in the target with source color/description
# - Prevents infinite loops using a content hash embedded in a hidden marker
# - Idempotent comment syncing using a hidden original-comment-id marker
#
# ✅ Setup (do this in BOTH repos):
# 1) Create a classic Personal Access Token (PAT) with at least `repo` scope that can access BOTH repos.
#    Save it as a secret named: MIRROR_TOKEN
# 2) Add repository variables (or edit `env:` below) to point to the counterpart repo:
#      MIRROR_TARGET_OWNER = "other-owner-or-org"
#      MIRROR_TARGET_REPO  = "other-repo-name"
# 3) Commit this workflow file to BOTH repos. Each should point to the other via variables above.
#
# Notes:
# - If assignees/milestones/users differ across repos, this action ignores them by default (labels + state + text + comments sync).
# - If you later change labels on one side, they’ll be created/updated on the other automatically.
# - Comment edits and deletes are mirrored too.

name: Issue Mirror

on:
  issues:
    types: [opened, edited, closed, reopened, labeled, unlabeled]
  issue_comment:
    types: [created, edited, deleted]

permissions:
  contents: read
  issues: write

env:
  MIRROR_TARGET_OWNER: ${{ vars.MIRROR_TARGET_OWNER }}
  MIRROR_TARGET_REPO:  ${{ vars.MIRROR_TARGET_REPO }}

jobs:
  mirror:
    runs-on: ubuntu-latest
    if: ${{ vars.MIRROR_TARGET_OWNER != '' && vars.MIRROR_TARGET_REPO != '' }}

    steps:
      - name: Mirror issue and comments
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.MIRROR_TOKEN }}
          script: |
            const crypto = require('crypto');

            // ---- Helpers ----
            const TARGET_OWNER = process.env.MIRROR_TARGET_OWNER;
            const TARGET_REPO  = process.env.MIRROR_TARGET_REPO;

            if (!TARGET_OWNER || !TARGET_REPO) {
              core.setFailed('MIRROR_TARGET_OWNER or MIRROR_TARGET_REPO not configured.');
              return;
            }

            const ctx = context; // github context
            const isIssueEvent = !!ctx.payload.issue;
            const isCommentEvent = !!ctx.payload.comment;

            const SRC_OWNER = ctx.repo.owner;
            const SRC_REPO  = ctx.repo.repo;
            const SRC_ISSUE_NUMBER = isIssueEvent ? ctx.payload.issue.number : ctx.payload.issue.number;

            const MIRROR_TAG_RE = /<!--\s*MIRROR:\s*([^#\s\/]+)\/(\S+?)#(\d+)\s*\|\s*hash:\s*([a-f0-9]{40})\s*-->/i;
            const COMMENT_ORIG_TAG_RE = /<!--\s*ORIG_COMMENT_ID:(\d+)\s*-->/i;

            function stripMirrorTag(body) {
              if (!body) return '';
              return body.replace(MIRROR_TAG_RE, '').trim();
            }

            function computeIssueHash({ title, body, labels, state }) {
              const norm = {
                title: title || '',
                body: stripMirrorTag(body || ''),
                labels: (labels || []).map(l => (typeof l === 'string' ? l : l.name)).sort(),
                state: state || 'open'
              };
              const str = JSON.stringify(norm);
              return crypto.createHash('sha1').update(str).digest('hex');
            }

            function embedMirrorTag(body, targetOwner, targetRepo, targetNumber, hash) {
              const tag = `<!-- MIRROR: ${targetOwner}/${targetRepo}#${targetNumber} | hash: ${hash} -->`;
              const clean = stripMirrorTag(body || '');
              return `${clean}\n\n${tag}`.trim();
            }

            async function ensureLabelsExist(target, labels) {
              // labels: array of {name, color, description} or strings
              const byName = {};
              for (const l of labels) {
                const name = typeof l === 'string' ? l : l.name;
                const color = typeof l === 'string' ? 'ededed' : (l.color || 'ededed');
                const description = typeof l === 'string' ? '' : (l.description || '');
                if (!name) continue;
                if (byName[name]) continue;
                byName[name] = { color, description };
              }

              for (const [name, meta] of Object.entries(byName)) {
                try {
                  await github.rest.issues.getLabel({ ...target, name });
                } catch (e) {
                  if (e.status === 404) {
                    await github.rest.issues.createLabel({ ...target, name, color: meta.color, description: meta.description });
                  } else {
                    throw e;
                  }
                }
              }
            }

            async function findOrCreateTargetIssue(source, target) {
              const srcIssue = (await github.rest.issues.get({ ...source })).data;

              // Try to read existing mirror tag to discover counterpart
              const m = MIRROR_TAG_RE.exec(srcIssue.body || '');
              if (m) {
                const [, towner, trepo, tnum] = m;
                const num = parseInt(tnum, 10);
                try {
                  const tgtIssue = (await github.rest.issues.get({ owner: towner, repo: trepo, issue_number: num })).data;
                  return { srcIssue, tgtIssue, existing: true };
                } catch (e) {
                  // Fall-through to recreate if counterpart was deleted
                }
              }

              // No counterpart found -> create one
              const labels = srcIssue.labels.map(l => ({ name: l.name, color: l.color, description: l.description }));
              await ensureLabelsExist(target, labels);

              const srcHash = computeIssueHash({
                title: srcIssue.title,
                body: srcIssue.body,
                labels: labels.map(l=>l.name),
                state: srcIssue.state
              });

              const created = (await github.rest.issues.create({
                ...target,
                title: srcIssue.title,
                body: embedMirrorTag(srcIssue.body || '', source.owner, source.repo, source.issue_number, srcHash),
                labels: labels.map(l => l.name),
                state: srcIssue.state
              })).data;

              // Update source to include back-reference
              const tgtHash = computeIssueHash({
                title: created.title,
                body: created.body,
                labels: created.labels.map(l => l.name),
                state: created.state
              });

              await github.rest.issues.update({
                ...source,
                body: embedMirrorTag(srcIssue.body || '', target.owner, target.repo, created.number, tgtHash)
              });

              return { srcIssue: (await github.rest.issues.get({ ...source })).data, tgtIssue: created, existing: false };
            }

            async function syncIssueCore(source, target, srcIssue, tgtIssue) {
              const srcLabels = srcIssue.labels.map(l => ({ name: l.name, color: l.color, description: l.description }));
              const tgtLabels = tgtIssue.labels.map(l => ({ name: l.name, color: l.color, description: l.description }));

              // Ensure labels exist on target
              await ensureLabelsExist(target, srcLabels);

              const desired = {
                title: srcIssue.title,
                body: embedMirrorTag(srcIssue.body || '', target.owner, target.repo, tgtIssue.number, computeIssueHash({
                  title: srcIssue.title,
                  body: srcIssue.body,
                  labels: srcLabels.map(l=>l.name),
                  state: srcIssue.state
                })),
                labels: srcLabels.map(l => l.name),
                state: srcIssue.state
              };

              const currentHashMatch = MIRROR_TAG_RE.exec(tgtIssue.body || '');
              const currentHash = currentHashMatch ? currentHashMatch[4] : null;
              const desiredHash = computeIssueHash({ title: desired.title, body: desired.body, labels: desired.labels, state: desired.state });

              const needTitle = tgtIssue.title !== desired.title;
              const needBody  = stripMirrorTag(tgtIssue.body || '') !== stripMirrorTag(desired.body || '');
              const needState = tgtIssue.state !== desired.state;
              const haveLabels = tgtLabels.map(l=>l.name).sort().join(',');
              const wantLabels = desired.labels.slice().sort().join(',');
              const needLabels = haveLabels !== wantLabels;

              // Skip if hashes already match (prevents loops)
              if (currentHash && currentHash === desiredHash && !needLabels) {
                core.info('Target already up to date (hash match).');
              } else {
                await github.rest.issues.update({ ...target, issue_number: tgtIssue.number, title: desired.title, body: desired.body, state: desired.state });
                if (needLabels) {
                  await github.rest.issues.setLabels({ ...target, issue_number: tgtIssue.number, labels: desired.labels });
                }
              }
            }

            async function syncComments(source, target, srcIssue, tgtIssue) {
              // Build maps by original comment id marker to avoid duplicates
              const srcComments = await github.paginate(github.rest.issues.listComments, { ...source, per_page: 100 });
              const tgtComments = await github.paginate(github.rest.issues.listComments, { ...target, issue_number: tgtIssue.number, per_page: 100 });

              const tgtByOrigId = new Map();
              for (const c of tgtComments) {
                const m = COMMENT_ORIG_TAG_RE.exec(c.body || '');
                if (m) tgtByOrigId.set(m[1], c);
              }

              for (const c of srcComments) {
                // Ignore system/actor: if the body already has our tag with this original id
                const origId = String(c.id);
                if (tgtByOrigId.has(origId)) {
                  // Possibly update if edited
                  const existing = tgtByOrigId.get(origId);
                  // Compare content without tag
                  const srcBodyCore = (c.body || '').replace(COMMENT_ORIG_TAG_RE, '').trim();
                  const tgtBodyCore = (existing.body || '').replace(COMMENT_ORIG_TAG_RE, '').trim();
                  if (srcBodyCore !== tgtBodyCore) {
                    await github.rest.issues.updateComment({ ...target, comment_id: existing.id, body: `${srcBodyCore}\n\n<!-- ORIG_COMMENT_ID:${origId} -->` });
                  }
                } else {
                  const coreBody = (c.body || '').replace(COMMENT_ORIG_TAG_RE, '').trim();
                  await github.rest.issues.createComment({ ...target, issue_number: tgtIssue.number, body: `${coreBody}\n\n<!-- ORIG_COMMENT_ID:${origId} -->` });
                }
              }

              // Handle deletions: if a comment exists on target with ORIG id that no longer exists on source, delete it
              const srcIds = new Set(srcComments.map(c => String(c.id)));
              for (const [origId, existing] of tgtByOrigId.entries()) {
                if (!srcIds.has(origId)) {
                  await github.rest.issues.deleteComment({ ...target, comment_id: existing.id });
                }
              }
            }

            async function mirrorFlow() {
              const source = { owner: SRC_OWNER, repo: SRC_REPO, issue_number: SRC_ISSUE_NUMBER };
              const target = { owner: TARGET_OWNER, repo: TARGET_REPO };

              // Find or create counterpart
              const { srcIssue, tgtIssue } = await findOrCreateTargetIssue(source, target);

              // If event is comment-only, just sync comments one way
              if (isCommentEvent) {
                await syncComments(source, { ...target, issue_number: tgtIssue.number }, srcIssue, tgtIssue);
                return;
              }

              // Sync core fields
              await syncIssueCore(source, { ...target, issue_number: tgtIssue.number }, srcIssue, tgtIssue);

              // Sync comments too (covers edits/deletes on issue edits)
              await syncComments(source, { ...target, issue_number: tgtIssue.number }, srcIssue, tgtIssue);
            }

            await mirrorFlow();
